// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
  baseUrl:
    | "https://api.markup.ai"
    | "https://api.stg.markup.ai"
    | "https://api.dev.markup.ai"
    | "http://localhost:8000"
    | (string & {});
};

/**
 * APIKeyCreate
 *
 * Model for creating a new API key.
 */
export type ApiKeyCreate = {
  /**
   * Name
   *
   * The name of the API key.
   */
  name: string;
  /**
   * Expires At
   *
   * The date and time the API key will expire.
   */
  expires_at?: string | null;
};

/**
 * APIKeyRead
 *
 * Model for reading API key data. Contains only safe fields for security.
 */
export type ApiKeyRead = {
  /**
   * Name
   *
   * The name of the API key.
   */
  name: string;
  /**
   * Expires At
   *
   * The date and time the API key will expire.
   */
  expires_at?: string | null;
  /**
   * Id
   */
  id: string;
  /**
   * Truncated Key
   */
  truncated_key: string;
  /**
   * Organization Id
   */
  organization_id: string;
  /**
   * Created At
   */
  created_at: string;
  /**
   * Created By
   */
  created_by: string | null;
};

/**
 * APIKeyReadWithSecret
 *
 * Model for reading API key data including the secret key. Use with caution.
 */
export type ApiKeyReadWithSecret = {
  /**
   * Name
   *
   * The name of the API key.
   */
  name: string;
  /**
   * Expires At
   *
   * The date and time the API key will expire.
   */
  expires_at?: string | null;
  /**
   * Id
   */
  id: string;
  /**
   * Truncated Key
   */
  truncated_key: string;
  /**
   * Organization Id
   */
  organization_id: string;
  /**
   * Created At
   */
  created_at: string;
  /**
   * Created By
   */
  created_by: string | null;
  /**
   * Key
   */
  key: string;
};

/**
 * APIKeyUpdate
 *
 * Model for updating API key fields. All fields are optional.
 */
export type ApiKeyUpdate = {
  /**
   * Name
   *
   * The name of the API key.
   */
  name?: string | null;
  /**
   * Expires At
   *
   * The date and time the API key will expire.
   */
  expires_at?: string | null;
};

/**
 * AccountMetadata
 */
export type AccountMetadata = {
  /**
   * First Name
   */
  first_name: string;
  /**
   * Last Name
   */
  last_name: string;
  /**
   * Job Title
   */
  job_title: string;
  /**
   * User Role
   */
  user_role: string;
  /**
   * Marketing Consent
   */
  marketing_consent: boolean;
};

/**
 * AccountResponse
 */
export type AccountResponse = {
  organization: OrganizationResponseFull;
  user_profile: UserProfileResponse;
};

/**
 * ActorType
 */
export enum ActorType {
  USER = "user",
  SYSTEM = "system",
  STRIPE = "stripe",
  ADMIN = "admin",
}

/**
 * AnalysisScore
 */
export type AnalysisScore = {
  clarity?: ClarityScore | null;
  tone?: ToneScore | null;
};

/**
 * AuthResponse
 */
export type AuthResponse = {
  /**
   * Api Key Id
   *
   * Contains the ID of the API key within our api_keys table
   */
  api_key_id?: string | null;
  /**
   * Email
   *
   * Contains the email of the user who signed in with the API key
   */
  email?: string | null;
  /**
   * Id
   *
   * Contains the source prefix and truncated key of the API key used to authenticate the user. Example: key|1234567890
   */
  id: string;
  /**
   * Org Id
   *
   * Contains the ID of the organization to which the user belongs
   */
  org_id: string;
  /**
   * Org Name
   *
   * Contains the name of the organization to which the user belongs
   */
  org_name: string;
  /**
   * Permissions
   *
   * Contains the permissions assigned to the API key
   */
  permissions: Array<string>;
  /**
   * Tokens Used
   *
   * Number of tokens the organization has used
   */
  tokens_used?: number | null;
  /**
   * Token Limit
   *
   * Maximum number of tokens the organization can use
   */
  token_limit?: number | null;
  /**
   * Org Is Internal
   *
   * Whether the organization is an internal organization
   */
  org_is_internal?: boolean;
};

/**
 * BaseStyleGuideType
 */
export enum BaseStyleGuideType {
  AP = "ap",
  CHICAGO = "chicago",
  MICROSOFT = "microsoft",
}

/**
 * BatchStyleCheckRequestBody
 */
export type BatchStyleCheckRequestBody = {
  /**
   * The language variant you'd like us to use for analysis. Choose from American English, British English, or other supported dialects.
   */
  dialect: Dialects;
  /**
   * The tone variation you're aiming for. Options include formal, academic, casual, and other tone variations to match your content goals.
   */
  tone?: Tones | null;
  /**
   * Style Guide
   *
   * The style guide to follow for your content. You can use a style guide ID or choose from built-in options: `ap`, `chicago`, or `microsoft`.
   */
  style_guide: string;
  /**
   * Webhook Url
   *
   * A URL that results will be POSTed to once the process completes.
   */
  webhook_url?: string | null;
  /**
   * File Uploads
   *
   * The documents to analyze. Text (.txt), Markdown (.md), HTML (.html .htm), DITA (.dita, .xml), and PDF (.pdf) files are accepted. The max file size is 1.5 MB.
   */
  file_uploads: Array<Blob | File>;
};

/**
 * BatchStyleResponse
 */
export type BatchStyleResponse = {
  /**
   * Workflows
   *
   * List of workflow information for each workflow in the batch
   */
  workflows?: Array<WorkflowInfo> | null;
};

/**
 * BatchStyleSuggestionRequestBody
 */
export type BatchStyleSuggestionRequestBody = {
  /**
   * The language variant you'd like us to use for analysis. Choose from American English, British English, or other supported dialects.
   */
  dialect: Dialects;
  /**
   * The tone variation you're aiming for. Options include formal, academic, casual, and other tone variations to match your content goals.
   */
  tone?: Tones | null;
  /**
   * Style Guide
   *
   * The style guide to follow for your content. You can use a style guide ID or choose from built-in options: `ap`, `chicago`, or `microsoft`.
   */
  style_guide: string;
  /**
   * Webhook Url
   *
   * A URL that results will be POSTed to once the process completes.
   */
  webhook_url?: string | null;
  /**
   * File Uploads
   *
   * The documents to analyze. Text (.txt), Markdown (.md), HTML (.html .htm), DITA (.dita, .xml), and PDF (.pdf) files are accepted. The max file size is 1.5 MB.
   */
  file_uploads: Array<Blob | File>;
};

/**
 * BillingCycle
 *
 * Billing cycle enumeration
 */
export enum BillingCycle {
  MONTHLY = "monthly",
  YEARLY = "yearly",
  ONE_TIME = "one_time",
}

/**
 * Body_Style Guides-update_style_guide
 */
export type BodyStyleGuidesUpdateStyleGuide = {
  /**
   * Name
   *
   * The name of the style guide.
   */
  name?: string | null;
  /**
   * Terminology Domain Ids
   *
   * List of domain IDs to filter terminology searches by. NULL or empty list means no filtering.
   */
  terminology_domain_ids?: Array<string> | null;
};

/**
 * Body_Terminology-import_terminology
 */
export type BodyTerminologyImportTerminology = {
  /**
   * File
   *
   * CSV or ACTIF XML file containing terminology data
   */
  file: Blob | File;
};

/**
 * BulkInvitationRequest
 */
export type BulkInvitationRequest = {
  /**
   * Invitations
   *
   * List of invitations (max 50)
   */
  invitations: Array<Invitation>;
};

/**
 * BulkInvitationResponse
 */
export type BulkInvitationResponse = {
  /**
   * Succeeded
   */
  succeeded: Array<string>;
  /**
   * Failed
   */
  failed: Array<InvitationResult>;
  /**
   * Total
   */
  total: number;
  /**
   * Success Count
   */
  success_count: number;
  /**
   * Failure Count
   */
  failure_count: number;
};

/**
 * CancelCancelationRequest
 *
 * Request model for canceling a cancel subscription request
 */
export type CancelCancelationRequest = {
  /**
   * Order Id
   */
  order_id: string;
};

/**
 * CancelCancelationResponse
 *
 * Response model for canceling a cancel subscription request
 */
export type CancelCancelationResponse = {
  /**
   * Message
   */
  message: string;
};

/**
 * CancelDowngradeRequest
 *
 * Request model for canceling a downgrade request
 */
export type CancelDowngradeRequest = {
  /**
   * Order Id
   */
  order_id?: string | null;
};

/**
 * CancelDowngradeResponse
 *
 * Response model for canceling a downgrade request
 */
export type CancelDowngradeResponse = {
  /**
   * Message
   */
  message: string;
};

/**
 * CancelSubscriptionRequest
 *
 * Request model for canceling a subscription
 */
export type CancelSubscriptionRequest = {
  /**
   * Order Id
   */
  order_id?: string | null;
  /**
   * Cancel Reason
   */
  cancel_reason?: string | null;
};

/**
 * CancelSubscriptionResponse
 *
 * Response model for canceling a subscription
 */
export type CancelSubscriptionResponse = {
  /**
   * Message
   */
  message: string;
};

/**
 * ClarityCategory
 */
export enum ClarityCategory {
  SIMPLER_WORDS = "Simpler Words",
  COMPLEX_VERB_TENSES = "Complex Verb Tenses",
  HIDDEN_VERBS = "Hidden Verbs",
  DIRECT_STATEMENTS = "Direct Statements",
  PASSIVE_VOICE = "Passive Voice",
  PHRASAL_VERBS = "Phrasal Verbs",
  FORMAL_GRAMMAR_FORMS = "Formal Grammar Forms",
  UNNECESSARY_WORDS = "Unnecessary Words",
  SENTENCE_SPLITTING = "Sentence Splitting",
  CONCISE_WORDING = "Concise Wording",
}

/**
 * ClarityScore
 */
export type ClarityScore = {
  /**
   * Score
   */
  score?: number | null;
  /**
   * Flesch Reading Ease
   */
  flesch_reading_ease?: number | null;
  /**
   * Sentence Complexity
   */
  sentence_complexity?: number | null;
  /**
   * Vocabulary Complexity
   */
  vocabulary_complexity?: number | null;
  /**
   * Sentence Count
   */
  sentence_count?: number | null;
  /**
   * Word Count
   */
  word_count?: number | null;
  /**
   * Average Sentence Length
   */
  average_sentence_length?: number | null;
};

/**
 * Color
 */
export type Color = {
  /**
   * Value
   */
  value: string;
  /**
   * Min Score
   */
  min_score: number;
};

/**
 * ConfigOptions
 */
export type ConfigOptions = {
  dialect?: Dialects | null;
  style_guide?: HeliosOneActivitiesEngineSharedModelsStyleGuide | null;
  tone?: Tones | null;
};

/**
 * ConsistencyCategory
 */
export enum ConsistencyCategory {
  CONSISTENT_PUNCTUATION = "Consistent Punctuation",
  CONSISTENT_CAPITALIZATION = "Consistent Capitalization",
  "NUMBERS,_DATES,_AND_TIMES" = "Numbers, Dates, and Times",
  INCLUSIVE_LANGUAGE = "Inclusive Language",
  SPECIAL_STYLE_GUIDE_REQUIREMENTS = "Special Style Guide Requirements",
  OTHER = "other",
}

/**
 * ConsistencyScore
 */
export type ConsistencyScore = {
  /**
   * Score
   */
  score?: number | null;
  /**
   * Issues
   */
  issues?: number | null;
};

/**
 * ConstantsResponse
 */
export type ConstantsResponse = {
  /**
   * Dialects
   */
  dialects?: Array<Dialects>;
  /**
   * Tones
   */
  tones?: Array<Tones>;
  /**
   * Style Guides
   */
  style_guides?: {
    [key: string]: string;
  };
  /**
   * Colors
   */
  colors?: {
    [key: string]: Color;
  };
};

/**
 * CooldownInfo
 *
 * Cooldown information for an API key.
 */
export type CooldownInfo = {
  /**
   * Api Key
   *
   * The API key identifier
   */
  api_key: string;
  /**
   * Remaining Seconds
   *
   * Remaining cooldown time in seconds
   */
  remaining_seconds: number;
  /**
   * Cooldown Type
   *
   * Type of cooldown (increase/decrease)
   */
  cooldown_type: string;
};

/**
 * CreateSubscriptionRequest
 *
 * Request model for creating a subscription
 */
export type CreateSubscriptionRequest = {
  /**
   * Product Price Id
   */
  product_price_id: string;
};

/**
 * CreatorResponse
 */
export type CreatorResponse = {
  /**
   * Id
   */
  id: string;
  /**
   * Email
   */
  email: string;
};

/**
 * Dialects
 */
export enum Dialects {
  AMERICAN_ENGLISH = "american_english",
  BRITISH_ENGLISH = "british_english",
  CANADIAN_ENGLISH = "canadian_english",
}

/**
 * DomainCreateRequest
 */
export type DomainCreateRequest = {
  /**
   * Name
   */
  name: string;
  /**
   * Description
   */
  description?: string | null;
};

/**
 * DomainResponse
 */
export type DomainResponse = {
  /**
   * Id
   */
  id: string;
  /**
   * Name
   */
  name: string;
  /**
   * Description
   */
  description?: string | null;
  /**
   * Created At
   */
  created_at: string;
  /**
   * Updated At
   */
  updated_at: string;
  /**
   * Created By
   */
  created_by?: string | null;
  /**
   * Updated By
   */
  updated_by?: string | null;
  /**
   * Term Set Count
   */
  term_set_count?: number;
};

/**
 * DomainSummary
 */
export type DomainSummary = {
  /**
   * Id
   */
  id: string;
  /**
   * Name
   */
  name: string;
};

/**
 * DomainUpdateRequest
 */
export type DomainUpdateRequest = {
  /**
   * Name
   */
  name?: string | null;
  /**
   * Description
   */
  description?: string | null;
};

/**
 * EmailTestRequest
 */
export type EmailTestRequest = {
  /**
   * Template Name
   */
  template_name?: string;
  /**
   * Context
   */
  context?: {
    [key: string]: string;
  } | null;
};

/**
 * ErrorResponse
 */
export type ErrorResponse = {
  /**
   * Detail
   *
   * A description of the error that occurred.
   */
  detail: string;
  /**
   * Status
   *
   * The HTTP status code generated by the server for this issue
   */
  status: number;
  /**
   * Request Id
   *
   * A unique ID associated with the HTTP request.
   */
  request_id: string;
};

/**
 * EventCategory
 */
export enum EventCategory {
  SUBSCRIPTION = "subscription",
  BILLING = "billing",
  LIMITS = "limits",
  SETTINGS = "settings",
  PAYMENT = "payment",
  PLAN = "plan",
  USER_MANAGEMENT = "user_management",
  API_USAGE = "api_usage",
  ORGANIZATION = "organization",
}

/**
 * EventType
 */
export enum EventType {
  PENDING_DOWNGRADE = "pending_downgrade",
  PENDING_UPGRADE = "pending_upgrade",
  ORGANIZATION_CREATED_STRIPE_CUSTOMER = "organization_created_stripe_customer",
  ORGANIZATION_CREATED_CHECKOUT_SESSION = "organization_created_checkout_session",
  ORGANIZATION_UPDATED = "organization_updated",
  ORGANIZATION_RESOURCES_UPDATED = "organization_resources_updated",
  SUBSCRIPTION_CREATED = "subscription_created",
  SUBSCRIPTION_UPDATED = "subscription_updated",
  SUBSCRIPTION_DELETED = "subscription_deleted",
  SUBSCRIPTION_CANCELLED = "subscription_cancelled",
  SUBSCRIPTION_CANCEL_REQUESTED = "subscription_cancel_requested",
  SUBSCRIPTION_CANCELLED_CANCELATION = "subscription_cancelled_cancelation",
  SUBSCRIPTION_NOT_FOUND_ERROR = "subscription_not_found_error",
  SUBSCRIPTION_CANCELLED_ERROR = "subscription_cancelled_error",
  SUBSCRIPTION_CANCELLED_CANCELATION_ERROR = "subscription_cancelled_cancelation_error",
  PLAN_UPGRADED = "plan_upgraded",
  PLAN_DOWNGRADED = "plan_downgraded",
  ACCOUNT_SUSPENDED = "account_suspended",
  INCREASED_TERM_LIMIT = "increased_term_limit",
  INCREASED_STYLE_GUIDE_LIMIT = "increased_style_guide_limit",
  INCREASED_TOKEN_LIMIT = "increased_token_limit",
  DECREASED_TERM_LIMIT = "decreased_term_limit",
  DECREASED_STYLE_GUIDE_LIMIT = "decreased_style_guide_limit",
  DECREASED_TOKEN_LIMIT = "decreased_token_limit",
  PAYMENT_INITIATED = "payment_initiated",
  PAYMENT_SUCCEEDED = "payment_succeeded",
  PAYMENT_FAILED = "payment_failed",
  PAYMENT_METHOD_ATTACHED = "payment_method_attached",
  PAYMENT_SUCCEEDED_ERROR = "payment_succeeded_error",
  TOKEN_RESET = "token_reset",
}

/**
 * FeedbackRequest
 */
export type FeedbackRequest = {
  /**
   * Workflow Id
   */
  workflow_id: string;
  /**
   * Request Id
   */
  request_id: string;
  /**
   * Helpful
   */
  helpful: boolean;
  /**
   * Feedback
   */
  feedback?: string | null;
  /**
   * Original
   */
  original?: string | null;
  /**
   * Suggestion
   */
  suggestion?: string | null;
  /**
   * Category
   */
  category?: string | null;
};

/**
 * GlobalDefaultsResponse
 */
export type GlobalDefaultsResponse = {
  /**
   * Tier
   */
  tier: string;
  /**
   * Term Limit
   */
  term_limit: number;
  /**
   * Style Guide Limit
   */
  style_guide_limit: number;
  /**
   * Token Limit
   */
  token_limit: number;
  /**
   * Trial Period
   */
  trial_period: number;
};

/**
 * GlobalDefaultsUpdate
 */
export type GlobalDefaultsUpdate = {
  /**
   * Term Limit
   */
  term_limit?: number | null;
  /**
   * Style Guide Limit
   */
  style_guide_limit?: number | null;
  /**
   * Token Limit
   */
  token_limit?: number | null;
  /**
   * Trial Period
   */
  trial_period?: number | null;
};

/**
 * GrammarCategory
 */
export enum GrammarCategory {
  GRAMMAR_AGREEMENT = "Grammar Agreement",
  PUNCTUATION = "Punctuation",
  CAPITALIZATION = "Capitalization",
  SPELLING = "Spelling",
  SENTENCE_STRUCTURE = "Sentence Structure",
  VERB_FORMS = "Verb Forms",
  CONTEXT_FIT = "Context Fit",
  OTHER = "other",
}

/**
 * GrammarScore
 */
export type GrammarScore = {
  /**
   * Score
   */
  score?: number | null;
  /**
   * Issues
   */
  issues?: number | null;
};

/**
 * ImportSummary
 */
export type ImportSummary = {
  /**
   * Entries Processed
   */
  entries_processed?: number;
  /**
   * Term Sets Created
   */
  term_sets_created?: number;
  /**
   * Term Sets Deleted
   */
  term_sets_deleted?: number;
  /**
   * Terms Created Or Updated
   */
  terms_created_or_updated?: number;
  /**
   * Domains Created
   */
  domains_created?: number;
  /**
   * Domains Deleted
   */
  domains_deleted?: number;
  /**
   * Errors
   */
  errors?: Array<string>;
};

/**
 * Invitation
 */
export type Invitation = {
  /**
   * Role
   */
  role?: string | null;
  /**
   * Email
   */
  email: string;
};

/**
 * InvitationResult
 */
export type InvitationResult = {
  /**
   * Email
   */
  email: string;
  /**
   * Success
   */
  success: boolean;
  /**
   * Error
   */
  error?: string | null;
};

/**
 * InvitedUser
 */
export type InvitedUser = {
  /**
   * Role
   */
  role?: string | null;
  /**
   * Email
   */
  email: string;
  /**
   * Invite Sent At
   */
  invite_sent_at: string;
};

/**
 * Issue
 */
export type Issue = {
  /**
   * Original
   *
   * The original text
   */
  original: string;
  /**
   * Position details of the issue
   */
  position: Position;
  /**
   * Subcategory
   *
   * The sub-category of the change
   */
  subcategory:
    | GrammarCategory
    | ClarityCategory
    | ToneCategory
    | ConsistencyCategory
    | TermReplaceCategory;
  category: IssueCategory | null;
};

/**
 * IssueCategory
 */
export enum IssueCategory {
  CLARITY = "clarity",
  GRAMMAR = "grammar",
  CONSISTENCY = "consistency",
  TERMINOLOGY = "terminology",
  TONE = "tone",
}

/**
 * MatchedTerm
 */
export type MatchedTerm = {
  /**
   * Term
   */
  term: string;
  /**
   * Matched Ngram
   */
  matched_ngram: string;
};

/**
 * Member
 */
export type Member = {
  /**
   * Role
   */
  role?: string | null;
};

/**
 * OrderStatus
 */
export enum OrderStatus {
  ACTIVE = "active",
  PENDING = "pending",
  CANCELED = "canceled",
  CANCEL_REQUESTED = "cancel_requested",
  UPGRADE_REQUESTED = "upgrade_requested",
  DOWNGRADE_REQUESTED = "downgrade_requested",
  FAILED = "failed",
  PAST_DUE = "past_due",
  UNPAID = "unpaid",
  INCOMPLETE = "incomplete",
  INCOMPLETE_EXPIRED = "incomplete_expired",
}

/**
 * OrderType
 */
export enum OrderType {
  RECURRING = "recurring",
  ONETIME = "onetime",
  UNLIMITED = "unlimited",
}

/**
 * OrgEventHistory
 */
export type OrgEventHistory = {
  /**
   * Organization Id
   *
   * ID of the organization this event relates to
   */
  organization_id: string;
  /**
   * Actor Id
   *
   * ID of the admin or system user who triggered the event
   */
  actor_id: string | null;
  /**
   * Type of actor
   */
  actor_type: ActorType;
  /**
   * Event Category
   *
   * Event category for grouping
   */
  event_category: string;
  /**
   * Event Type
   *
   * Specific event type (free-form for finer granularity)
   */
  event_type: string;
  /**
   * Title
   *
   * Short title for the event (e.g., 'Plan Upgraded', 'Term Limit Increased')
   */
  title: string;
  /**
   * Description
   *
   * Detailed description of what happened
   */
  description: string;
  /**
   * Summary
   *
   * Brief summary for quick overview
   */
  summary?: string | null;
  /**
   * Modified Field Names
   *
   * Names of the modified fields
   */
  modified_field_names?: Array<string> | null;
  /**
   * Old Values
   *
   * Previous snapshot before the change
   */
  old_values?: {
    [key: string]: unknown;
  } | null;
  /**
   * New Values
   *
   * New snapshot after the change
   */
  new_values?: {
    [key: string]: unknown;
  } | null;
  /**
   * Is Visible
   *
   * Whether this event should be visible in the frontend
   */
  is_visible?: boolean;
  /**
   * Created At
   *
   * When the event record was created
   */
  created_at?: string;
  /**
   * Id
   */
  id?: string;
};

/**
 * Organization
 */
export type Organization = {
  /**
   * Id
   */
  id: string;
  /**
   * Name
   */
  name: string;
  /**
   * Display Name
   */
  display_name: string;
  /**
   * Picture
   */
  picture: string;
};

/**
 * OrganizationMember
 */
export type OrganizationMember = {
  /**
   * Role
   */
  role?: string | null;
  /**
   * Email
   */
  email: string;
  /**
   * Name
   */
  name: string;
};

/**
 * OrganizationRequest
 */
export type OrganizationRequest = {
  /**
   * Name
   */
  name: string;
  /**
   * Admin
   */
  admin?: string | null;
  /**
   * Domain
   */
  domain: string;
  /**
   * Display Name
   */
  display_name?: string | null;
  /**
   * Token Limit
   */
  token_limit?: number | null;
  /**
   * Expiration Days
   */
  expiration_days?: number | null;
  /**
   * Trial
   */
  trial?: boolean | null;
  /**
   * Tier
   */
  tier?: string;
  /**
   * Is Internal
   */
  is_internal?: boolean;
  /**
   * Is Acrolinx Classic
   */
  is_acrolinx_classic?: boolean;
};

/**
 * OrganizationResponse
 */
export type OrganizationResponse = {
  /**
   * Id
   */
  id: string;
  /**
   * Name
   */
  name: string;
  /**
   * Token Limit
   */
  token_limit: number;
  /**
   * Tokens Used
   */
  tokens_used: number;
  /**
   * Tier
   */
  tier: string;
  /**
   * Style Guide Limit
   */
  style_guide_limit: number;
  /**
   * Term Limit
   */
  term_limit: number;
  /**
   * Display Name
   */
  display_name?: string | null;
  /**
   * Created Date
   */
  created_date: string;
  /**
   * Expiration
   */
  expiration: string | null;
  /**
   * Domain
   */
  domain: string;
  created_by: CreatorResponse | null;
  /**
   * Is Internal
   */
  is_internal: boolean;
  /**
   * Is Acrolinx Classic
   */
  is_acrolinx_classic: boolean;
  /**
   * Trial
   */
  readonly trial: boolean;
  /**
   * Tokens
   */
  readonly tokens: number;
};

/**
 * OrganizationResponseAdmin
 */
export type OrganizationResponseAdmin = {
  /**
   * Id
   */
  id: string;
  /**
   * Name
   */
  name: string;
  /**
   * Token Limit
   */
  token_limit: number;
  /**
   * Tokens Used
   */
  tokens_used: number;
  /**
   * Tier
   */
  tier: string;
  /**
   * Style Guide Limit
   */
  style_guide_limit: number;
  /**
   * Term Limit
   */
  term_limit: number;
  /**
   * Display Name
   */
  display_name?: string | null;
  /**
   * Created Date
   */
  created_date: string;
  /**
   * Expiration
   */
  expiration: string | null;
  /**
   * Domain
   */
  domain: string;
  created_by: CreatorResponse | null;
  /**
   * Style Guides
   */
  style_guides?: number;
  /**
   * Term Sets
   */
  term_sets?: number;
  /**
   * Country
   */
  country: string | null;
  /**
   * Is Internal
   */
  is_internal: boolean;
  /**
   * Is Acrolinx Classic
   */
  is_acrolinx_classic: boolean;
  /**
   * Trial
   */
  readonly trial: boolean;
  /**
   * Tokens
   */
  readonly tokens: number;
};

/**
 * OrganizationResponseFull
 */
export type OrganizationResponseFull = {
  /**
   * Id
   */
  id: string;
  /**
   * Name
   */
  name: string;
  /**
   * Token Limit
   */
  token_limit: number;
  /**
   * Tokens Used
   */
  tokens_used: number;
  /**
   * Tier
   */
  tier: string;
  /**
   * Style Guide Limit
   */
  style_guide_limit: number;
  /**
   * Term Limit
   */
  term_limit: number;
  /**
   * Display Name
   */
  display_name?: string | null;
  /**
   * Created Date
   */
  created_date: string;
  /**
   * Expiration
   */
  expiration: string | null;
  /**
   * Domain
   */
  domain: string;
  created_by: CreatorResponse | null;
  /**
   * Style Guides
   */
  style_guides?: number;
  /**
   * Term Sets
   */
  term_sets?: number;
  /**
   * Country
   */
  country: string | null;
  /**
   * Is Internal
   */
  is_internal: boolean;
  /**
   * Is Acrolinx Classic
   */
  is_acrolinx_classic: boolean;
  /**
   * Trial
   */
  readonly trial: boolean;
  /**
   * Tokens
   */
  readonly tokens: number;
};

/**
 * OrganizationSignupRequest
 */
export type OrganizationSignupRequest = {
  /**
   * Display Name
   *
   * Display name for the organization
   */
  display_name: string;
  /**
   * User Role
   *
   * User role in the organization
   */
  user_role?: string | null;
  /**
   * Country
   *
   * Country of the organization
   */
  country?: string | null;
  /**
   * First Name
   *
   * First name of the user
   */
  first_name?: string | null;
  /**
   * Last Name
   *
   * Last name of the user
   */
  last_name?: string | null;
  /**
   * Job Title
   *
   * Job title of the user
   */
  job_title?: string | null;
  /**
   * Marketing Consent
   *
   * User consent for marketing communications
   */
  marketing_consent?: boolean | null;
  /**
   * Captcha Response
   *
   * CAPTCHA response
   */
  captcha_response: string;
};

/**
 * OrganizationSignupResponse
 */
export type OrganizationSignupResponse = {
  /**
   * Organization Id
   */
  organization_id: string;
  /**
   * Organization Name
   */
  organization_name: string;
  /**
   * Display Name
   */
  display_name: string;
  /**
   * Message
   */
  message: string;
};

/**
 * OrganizationUpdate
 */
export type OrganizationUpdate = {
  /**
   * Domain
   */
  domain?: string | null;
  /**
   * Display Name
   */
  display_name?: string | null;
  /**
   * Token Limit
   */
  token_limit?: number | null;
  /**
   * Tokens Used
   */
  tokens_used?: number | null;
  /**
   * Expiration Days
   */
  expiration_days?: number | null;
  /**
   * Expiration Date
   */
  expiration_date?: string | null;
  /**
   * Trial
   */
  trial?: boolean | null;
  /**
   * Tier
   */
  tier?: string | null;
  /**
   * Style Guide Limit
   */
  style_guide_limit?: number | null;
  /**
   * Term Limit
   */
  term_limit?: number | null;
  /**
   * Is Internal
   */
  is_internal?: boolean | null;
  /**
   * Is Acrolinx Classic
   */
  is_acrolinx_classic?: boolean | null;
};

/**
 * OriginalContent
 */
export type OriginalContent = {
  /**
   * Issues
   */
  issues?: Array<Issue>;
  scores?: ScoreOutput | null;
};

/**
 * Page[APIKeyRead]
 */
export type PageApiKeyRead = {
  /**
   * Items
   */
  items: Array<ApiKeyRead>;
  /**
   * Total Items
   */
  total_items: number;
  /**
   * Page
   */
  page: number;
  /**
   * Page Size
   */
  page_size: number;
  /**
   * Total Pages
   *
   * The total number of pages.
   */
  readonly total_pages: number;
};

/**
 * Page[StyleGuide]
 */
export type PageStyleGuide = {
  /**
   * Items
   */
  items: Array<HeliosOneDatabaseModelsStyleGuideStyleGuide>;
  /**
   * Total Items
   */
  total_items: number;
  /**
   * Page
   */
  page: number;
  /**
   * Page Size
   */
  page_size: number;
  /**
   * Total Pages
   *
   * The total number of pages.
   */
  readonly total_pages: number;
};

/**
 * Page[TermSetWithTerms]
 */
export type PageTermSetWithTerms = {
  /**
   * Items
   */
  items: Array<TermSetWithTerms>;
  /**
   * Total Items
   */
  total_items: number;
  /**
   * Page
   */
  page: number;
  /**
   * Page Size
   */
  page_size: number;
  /**
   * Total Pages
   *
   * The total number of pages.
   */
  readonly total_pages: number;
};

/**
 * PaginatedDomainsResponse
 */
export type PaginatedDomainsResponse = {
  /**
   * Domains
   */
  domains: Array<DomainResponse>;
  /**
   * Total Count
   */
  total_count: number;
  /**
   * Page
   */
  page: number;
  /**
   * Page Size
   */
  page_size: number;
  /**
   * Total Pages
   */
  total_pages: number;
};

/**
 * PaginatedOrganizationResponse
 */
export type PaginatedOrganizationResponse = {
  /**
   * Total
   */
  total: number;
  /**
   * Page
   */
  page: number;
  /**
   * Page Size
   */
  page_size: number;
  /**
   * Organizations
   */
  organizations: Array<OrganizationResponse>;
};

/**
 * PaginatedTermSetsResponse
 *
 * Pageable response for term sets in term management UI
 */
export type PaginatedTermSetsResponse = {
  /**
   * Term Sets
   */
  term_sets: Array<TermSetWithTerms>;
  /**
   * Total Count
   */
  total_count: number;
  /**
   * Total Unfiltered Term Sets
   */
  total_unfiltered_term_sets: number;
  /**
   * Page
   */
  page: number;
  /**
   * Page Size
   */
  page_size: number;
  /**
   * Total Pages
   */
  total_pages: number;
};

/**
 * Position
 */
export type Position = {
  /**
   * Start Index
   *
   * The start index of the issue in the text
   */
  start_index: number;
};

/**
 * ProductPriceResponse
 *
 * Response model for product price data
 */
export type ProductPriceResponse = {
  /**
   * Product Price Id
   */
  product_price_id: string;
  /**
   * Product Id
   */
  product_id?: string | null;
  /**
   * Amount Cents
   */
  amount_cents: number;
  /**
   * Currency
   */
  currency: string;
  /**
   * Billing Cycle
   */
  billing_cycle?: string | null;
  /**
   * Version
   */
  version: number;
  /**
   * Active
   */
  active: boolean;
};

/**
 * ProductType
 */
export enum ProductType {
  PLAN = "plan",
  ADDON = "addon",
  FREE_ADDON = "free_addon",
}

/**
 * ProductWithPricesResponse
 *
 * Response model for product with its prices
 */
export type ProductWithPricesResponse = {
  /**
   * Product Id
   */
  product_id: string;
  /**
   * Type
   */
  type: string;
  /**
   * Name
   */
  name: string;
  /**
   * Description
   */
  description: string | null;
  /**
   * Token Limit
   */
  token_limit: number;
  /**
   * Style Guide Limit
   */
  style_guide_limit: number;
  /**
   * Term Limit
   */
  term_limit: number;
  /**
   * Active
   */
  active: boolean;
  /**
   * Prices
   */
  prices?: Array<ProductPriceResponse>;
};

/**
 * QualityScore
 */
export type QualityScore = {
  /**
   * Score
   */
  score?: number | null;
  grammar?: GrammarScore | null;
  consistency?: ConsistencyScore | null;
  terminology?: TerminologyScore | null;
};

/**
 * RewriteContent
 */
export type RewriteContent = {
  /**
   * Text
   */
  text?: string | null;
  scores?: ScoreOutput | null;
};

/**
 * RewriteResponse
 */
export type RewriteResponse = {
  config?: ConfigOptions | null;
  original?: SuggestionOriginalContent | null;
  rewrite?: RewriteContent | null;
  workflow: WorkflowInfo;
};

/**
 * ScoreOutput
 */
export type ScoreOutput = {
  quality?: QualityScore | null;
  analysis?: AnalysisScore | null;
};

/**
 * StaffRequest
 */
export type StaffRequest = {
  /**
   * Admin
   */
  admin?: boolean;
  /**
   * Email
   */
  email: string;
};

/**
 * StaffResponse
 */
export type StaffResponse = {
  /**
   * Name
   */
  name: string;
  /**
   * Email
   */
  email: string;
  /**
   * Admin
   */
  admin: boolean;
};

/**
 * StaffUpdate
 */
export type StaffUpdate = {
  /**
   * Admin
   */
  admin?: boolean;
};

/**
 * StripeSubscriptionStatus
 */
export enum StripeSubscriptionStatus {
  ACTIVE = "active",
  CANCELED = "canceled",
  NOT_STARTED = "not_started",
  PAST_DUE = "past_due",
  UNPAID = "unpaid",
  INCOMPLETE = "incomplete",
  INCOMPLETE_EXPIRED = "incomplete_expired",
  TRIALING = "trialing",
}

/**
 * StyleCheckRequestBody
 */
export type StyleCheckRequestBody = {
  /**
   * The language variant you'd like us to use for analysis. Choose from American English, British English, or other supported dialects.
   */
  dialect: Dialects;
  /**
   * The tone variation you're aiming for. Options include formal, academic, casual, and other tone variations to match your content goals.
   */
  tone?: Tones | null;
  /**
   * Style Guide
   *
   * The style guide to follow for your content. You can use a style guide ID or choose from built-in options: `ap`, `chicago`, or `microsoft`.
   */
  style_guide: string;
  /**
   * Webhook Url
   *
   * A URL that results will be POSTed to once the process completes.
   */
  webhook_url?: string | null;
  /**
   * File Upload
   *
   * The document to analyze. Text (.txt), Markdown (.md), HTML (.html .htm), DITA (.dita, .xml), and PDF (.pdf) files are accepted. The max file size is 1.5 MB.
   */
  file_upload: Blob | File;
};

/**
 * StyleCheckResponse
 */
export type StyleCheckResponse = {
  config?: ConfigOptions | null;
  original?: OriginalContent | null;
  workflow: WorkflowInfo;
};

/**
 * StyleGuideRequestBody
 */
export type StyleGuideRequestBody = {
  /**
   * File Upload
   *
   * The document to analyze. We accept PDF files (.pdf) up to 2 MB.
   */
  file_upload: Blob | File;
  /**
   * Name
   *
   * A friendly name for your style guide to help you identify it later.
   */
  name: string;
  /**
   * The base style guide to extend (AP, Chicago, or Microsoft). If not provided, the style guide will be created from scratch.
   */
  base_style_guide?: BaseStyleGuideType | null;
  /**
   * Terminology Domain Ids
   *
   * List of domain IDs to filter terminology searches by. NULL or empty list means no filtering.
   */
  terminology_domain_ids?: Array<string> | null;
};

/**
 * StyleGuideResponse
 */
export type StyleGuideResponse = {
  /**
   * Id
   */
  id: string;
  /**
   * Name
   *
   * The name of the style guide.
   */
  name: string;
  /**
   * Created At
   *
   * The UTC date and time the style guide was created.
   */
  created_at: string;
  /**
   * Created By
   *
   * The ID of the user who created the style guide.
   */
  created_by: string;
  /**
   * The status of the submitted style guide.
   */
  status: StyleGuideStatus;
  /**
   * Updated At
   *
   * The UTC datetime that the style guide was last updated. If null, the style guide has never been updated.
   */
  updated_at?: string | null;
  /**
   * Updated By
   *
   * The ID of the user who last updated the style guide. If null, the style guide has never been updated.
   */
  updated_by?: string | null;
  /**
   * Summary
   *
   * User-friendly summary of the style guide's contents and characteristics
   */
  summary?: string | null;
  /**
   * The base style guide type that this style guide extends (AP, Chicago, or Microsoft).
   */
  base_style_guide_type?: BaseStyleGuideType | null;
  /**
   * Terminology Domain Ids
   *
   * List of domain IDs to filter terminology searches by. NULL or empty list means no filtering.
   */
  terminology_domain_ids?: Array<string> | null;
};

/**
 * StyleGuideStatus
 */
export enum StyleGuideStatus {
  RUNNING = "running",
  COMPLETED = "completed",
  FAILED = "failed",
  NOT_FOUND = "not_found",
}

/**
 * StyleGuides
 */
export enum StyleGuides {
  AP = "ap",
  CHICAGO = "chicago",
  MICROSOFT = "microsoft",
  STYLE_BRAND_IMPORTER = "style_brand_importer",
}

/**
 * StyleRewriteRequestBody
 */
export type StyleRewriteRequestBody = {
  /**
   * The language variant you'd like us to use for analysis. Choose from American English, British English, or other supported dialects.
   */
  dialect: Dialects;
  /**
   * The tone variation you're aiming for. Options include formal, academic, casual, and other tone variations to match your content goals.
   */
  tone?: Tones | null;
  /**
   * Style Guide
   *
   * The style guide to follow for your content. You can use a style guide ID or choose from built-in options: `ap`, `chicago`, or `microsoft`.
   */
  style_guide: string;
  /**
   * Webhook Url
   *
   * A URL that results will be POSTed to once the process completes.
   */
  webhook_url?: string | null;
  /**
   * File Upload
   *
   * The document to rewrite. Text (.txt), Markdown (.md), HTML (.html .htm), and DITA (.dita, .xml) files are accepted. The max file size is 1.5 MB.
   */
  file_upload: Blob | File;
};

/**
 * StyleSuggestionRequestBody
 */
export type StyleSuggestionRequestBody = {
  /**
   * The language variant you'd like us to use for analysis. Choose from American English, British English, or other supported dialects.
   */
  dialect: Dialects;
  /**
   * The tone variation you're aiming for. Options include formal, academic, casual, and other tone variations to match your content goals.
   */
  tone?: Tones | null;
  /**
   * Style Guide
   *
   * The style guide to follow for your content. You can use a style guide ID or choose from built-in options: `ap`, `chicago`, or `microsoft`.
   */
  style_guide: string;
  /**
   * Webhook Url
   *
   * A URL that results will be POSTed to once the process completes.
   */
  webhook_url?: string | null;
  /**
   * File Upload
   *
   * The document to analyze. Text (.txt), Markdown (.md), HTML (.html .htm), DITA (.dita, .xml), and PDF (.pdf) files are accepted. The max file size is 1.5 MB.
   */
  file_upload: Blob | File;
};

/**
 * SubscriptionLogResponse
 *
 * Response model for subscription log data
 */
export type SubscriptionLogResponse = {
  /**
   * Org Event History
   */
  org_event_history: Array<OrgEventHistory>;
};

/**
 * SubscriptionResponse
 *
 * Response model for subscription data
 */
export type SubscriptionResponse = {
  /**
   * Order Id
   */
  order_id: string;
  /**
   * Organization Id
   */
  organization_id: string;
  order_type: OrderType;
  billing_cycle: BillingCycle;
  order_status: OrderStatus;
  /**
   * Current Period Start
   */
  current_period_start: string;
  /**
   * Current Period End
   */
  current_period_end: string;
  /**
   * Cancel At Period End
   */
  cancel_at_period_end: boolean;
  stripe_subscription_status: StripeSubscriptionStatus;
  /**
   * Cancel Reason
   */
  cancel_reason?: string | null;
  /**
   * Updated At
   */
  updated_at: string;
  /**
   * Amount
   */
  amount: number;
  /**
   * Currency
   */
  currency: string;
  /**
   * Product Name
   */
  product_name: string;
  /**
   * Product Type
   */
  product_type: string;
  /**
   * Created At
   */
  created_at: string;
  /**
   * Is Visible
   */
  is_visible: boolean;
};

/**
 * Suggestion
 */
export type Suggestion = {
  /**
   * Original
   *
   * The original text
   */
  original: string;
  /**
   * Position details of the issue
   */
  position: Position;
  /**
   * Subcategory
   *
   * The sub-category of the change
   */
  subcategory:
    | GrammarCategory
    | ClarityCategory
    | ToneCategory
    | ConsistencyCategory
    | TermReplaceCategory;
  /**
   * Suggestion
   *
   * The suggested replacement text
   */
  suggestion: string;
  category: IssueCategory | null;
};

/**
 * SuggestionOriginalContent
 */
export type SuggestionOriginalContent = {
  /**
   * Issues
   */
  issues?: Array<Suggestion>;
  scores?: ScoreOutput | null;
};

/**
 * SuggestionResponse
 */
export type SuggestionResponse = {
  config?: ConfigOptions | null;
  original?: SuggestionOriginalContent | null;
  workflow: WorkflowInfo;
};

/**
 * TermCreateRequest
 *
 * Payload to create a new term for a term set
 */
export type TermCreateRequest = {
  /**
   * Term
   */
  term: string;
  type: TermType;
};

/**
 * TermDetail
 *
 * Detailed term information for term management UI
 */
export type TermDetail = {
  /**
   * Id
   */
  id: string;
  /**
   * Term
   */
  term: string;
  type: TermType;
  /**
   * Created At
   */
  created_at: string;
  /**
   * Updated At
   */
  updated_at: string;
  /**
   * Created By
   */
  created_by?: string | null;
  /**
   * Updated By
   */
  updated_by?: string | null;
};

/**
 * TermItem
 */
export type TermItem = {
  /**
   * Term
   */
  term: string;
  /**
   * Type
   */
  type: string;
};

/**
 * TermReplaceCategory
 */
export enum TermReplaceCategory {
  TERMINOLOGY = "Terminology",
  OTHER = "other",
}

/**
 * TermResponse
 *
 * DB-mapped representation of a term.
 */
export type TermResponse = {
  /**
   * Id
   */
  id: string;
  /**
   * Term
   */
  term: string;
  type: TermType;
  /**
   * Created At
   */
  created_at: string;
  /**
   * Updated At
   */
  updated_at: string;
  /**
   * Created By
   */
  created_by?: string | null;
  /**
   * Updated By
   */
  updated_by?: string | null;
};

/**
 * TermSetCreateRequest
 *
 * Payload to create a new term set
 */
export type TermSetCreateRequest = {
  /**
   * Instructions
   */
  instructions: string;
  /**
   * Terms
   */
  terms?: Array<TermCreateRequest> | null;
  /**
   * Domain Ids
   */
  domain_ids?: Array<string> | null;
};

/**
 * TermSetResponse
 *
 * DB-mapped representation of a term set (no terms).
 */
export type TermSetResponse = {
  /**
   * Id
   */
  id: string;
  /**
   * Instructions
   */
  instructions: string;
  /**
   * Created At
   */
  created_at: string;
  /**
   * Updated At
   */
  updated_at: string;
  /**
   * Created By
   */
  created_by?: string | null;
  /**
   * Updated By
   */
  updated_by?: string | null;
};

/**
 * TermSetResult
 */
export type TermSetResult = {
  /**
   * Instructions
   */
  instructions: string;
  /**
   * Terms
   */
  terms: Array<TermItem>;
  /**
   * Matched Terms
   */
  matched_terms: Array<MatchedTerm>;
};

/**
 * TermSetUpdateRequest
 *
 * Payload to update an existing term set
 */
export type TermSetUpdateRequest = {
  /**
   * Instructions
   */
  instructions?: string | null;
  /**
   * Domain Ids
   */
  domain_ids?: Array<string> | null;
};

/**
 * TermSetWithTerms
 *
 * Term set with all associated terms for term management UI
 */
export type TermSetWithTerms = {
  /**
   * Id
   */
  id: string;
  /**
   * Instructions
   */
  instructions: string;
  /**
   * Created At
   */
  created_at: string;
  /**
   * Updated At
   */
  updated_at: string;
  /**
   * Created By
   */
  created_by?: string | null;
  /**
   * Updated By
   */
  updated_by?: string | null;
  /**
   * Terms
   */
  terms: Array<TermDetail>;
  /**
   * Domains
   */
  domains?: Array<DomainSummary>;
};

/**
 * TermType
 *
 * Represents the three types of terms in the terminology system.
 */
export enum TermType {
  PREFERRED = "preferred",
  DEPRECATED = "deprecated",
  CONTEXT_MATTERS = "context_matters",
}

/**
 * TermUpdateRequest
 *
 * Payload to update an existing term
 */
export type TermUpdateRequest = {
  /**
   * Term
   */
  term: string;
  type: TermType;
};

/**
 * TerminologyScore
 */
export type TerminologyScore = {
  /**
   * Score
   */
  score?: number | null;
  /**
   * Issues
   */
  issues?: number | null;
};

/**
 * TerminologySearchResponse
 */
export type TerminologySearchResponse = {
  /**
   * Results
   */
  results: Array<TermSetResult>;
};

/**
 * ThrottleConfig
 *
 * Throttle configuration for an API key.
 */
export type ThrottleConfig = {
  /**
   * Api Key
   *
   * The API key identifier
   */
  api_key: string;
  /**
   * Tpm Limit
   *
   * Tokens per minute limit
   */
  tpm_limit: number;
  /**
   * Tps Limit
   *
   * Tokens per second limit
   */
  tps_limit: number;
  /**
   * Tps Burst Ms
   *
   * TPS burst duration in milliseconds
   */
  tps_burst_ms: number;
  /**
   * Safety Margin
   *
   * Safety margin as a decimal (0.1 = 10%)
   */
  safety_margin: number;
  /**
   * Lease Ttl Ms
   *
   * Lease TTL in milliseconds
   */
  lease_ttl_ms: number;
  /**
   * Aimd Decrease Rate
   *
   * AIMD decrease rate as a decimal
   */
  aimd_decrease_rate: number;
  /**
   * Aimd Increase Rate
   *
   * AIMD increase rate as a decimal
   */
  aimd_increase_rate: number;
  /**
   * Aimd Clean Window Seconds
   *
   * AIMD clean window in seconds
   */
  aimd_clean_window_seconds: number;
  /**
   * Ttl Seconds
   *
   * Configuration TTL in seconds
   */
  ttl_seconds: number;
  /**
   * Ttl Minutes
   *
   * Configuration TTL in minutes
   */
  ttl_minutes: number;
  /**
   * Gsu Tpm Percentage
   *
   * Percentage of 1 GSU TPM capacity
   */
  gsu_tpm_percentage: number;
  /**
   * Gsu Tps Percentage
   *
   * Percentage of 1 GSU TPS capacity
   */
  gsu_tps_percentage: number;
};

/**
 * ThrottleMetricsResponse
 *
 * Response containing all throttle metrics.
 */
export type ThrottleMetricsResponse = {
  /**
   * Configurations
   *
   * List of all throttle configurations
   */
  configurations: Array<ThrottleConfig>;
  /**
   * Cooldowns
   *
   * List of active cooldowns
   */
  cooldowns: Array<CooldownInfo>;
  /**
   * Summary
   *
   * Summary statistics
   */
  summary: {
    [key: string]: unknown;
  };
  /**
   * Timestamp
   *
   * Timestamp of the metrics snapshot
   */
  timestamp: string;
};

/**
 * ThrottleResetRequest
 *
 * Request to reset or update throttle configuration.
 */
export type ThrottleResetRequest = {
  /**
   * Api Key
   *
   * The API key to reset/update
   */
  api_key: string;
  /**
   * Gsu Percentage
   *
   * Percentage of 1 GSU capacity (e.g., 1000 for 1000%)
   */
  gsu_percentage?: number;
  /**
   * Tpm Limit
   *
   * Optional: Override TPM limit directly
   */
  tpm_limit?: number | null;
  /**
   * Tps Limit
   *
   * Optional: Override TPS limit directly
   */
  tps_limit?: number | null;
  /**
   * Tps Burst Ms
   *
   * Optional: Override TPS burst window in milliseconds (default: keeps existing or 5000)
   */
  tps_burst_ms?: number | null;
  /**
   * Clear Aimd State
   *
   * Clear AIMD state (successes, 429 history)
   */
  clear_aimd_state?: boolean;
  /**
   * Reset Cooldowns
   *
   * Reset increase/decrease cooldowns
   */
  reset_cooldowns?: boolean;
};

/**
 * ThrottleResetResponse
 *
 * Response after resetting throttle configuration.
 */
export type ThrottleResetResponse = {
  /**
   * Api Key
   *
   * The API key that was reset
   */
  api_key: string;
  /**
   * Old Tpm Limit
   *
   * Previous TPM limit
   */
  old_tpm_limit: number | null;
  /**
   * Old Tps Limit
   *
   * Previous TPS limit
   */
  old_tps_limit: number | null;
  /**
   * New Tpm Limit
   *
   * New TPM limit
   */
  new_tpm_limit: number;
  /**
   * New Tps Limit
   *
   * New TPS limit
   */
  new_tps_limit: number;
  /**
   * Gsu Percentage
   *
   * Percentage of 1 GSU capacity
   */
  gsu_percentage: number;
  /**
   * Aimd State Cleared
   *
   * Whether AIMD state was cleared
   */
  aimd_state_cleared: boolean;
  /**
   * Cooldowns Reset
   *
   * Whether cooldowns were reset
   */
  cooldowns_reset: boolean;
};

/**
 * ThrottleToggleRequest
 *
 * Request to toggle rate limiting on/off.
 */
export type ThrottleToggleRequest = {
  /**
   * Enabled
   *
   * Whether to enable or disable rate limiting
   */
  enabled: boolean;
};

/**
 * ThrottleToggleResponse
 *
 * Response after toggling rate limiting.
 */
export type ThrottleToggleResponse = {
  /**
   * Enabled
   *
   * Current rate limiting state
   */
  enabled: boolean;
  /**
   * Previous State
   *
   * Previous rate limiting state (None if not previously set)
   */
  previous_state: boolean | null;
  /**
   * Message
   *
   * Confirmation message
   */
  message: string;
};

/**
 * ToneCategory
 */
export enum ToneCategory {
  TONE_ALIGNED_WORDING = "Tone-Aligned Wording",
  TONE_SHAPING_STRUCTURE = "Tone-Shaping Structure",
  TONE_SIGNAL_PUNCTUATION = "Tone-Signal Punctuation",
  TRANSITIONS_AND_FLOW = "Transitions and Flow",
  ADDITIONAL_TONE_CHANGES = "Additional Tone Changes",
  OTHER = "other",
}

/**
 * ToneScore
 */
export type ToneScore = {
  /**
   * Score
   */
  score?: number | null;
  /**
   * Informality
   */
  informality?: number | null;
  /**
   * Liveliness
   */
  liveliness?: number | null;
  /**
   * Informality Alignment
   */
  informality_alignment?: number | null;
  /**
   * Liveliness Alignment
   */
  liveliness_alignment?: number | null;
};

/**
 * Tones
 */
export enum Tones {
  ACADEMIC = "academic",
  CONFIDENT = "confident",
  CONVERSATIONAL = "conversational",
  EMPATHETIC = "empathetic",
  ENGAGING = "engaging",
  FRIENDLY = "friendly",
  PROFESSIONAL = "professional",
  TECHNICAL = "technical",
}

/**
 * UpdateSubscriptionRequest
 *
 * Request model for updating a subscription
 */
export type UpdateSubscriptionRequest = {
  /**
   * New Product Price Id
   */
  new_product_price_id: string;
};

/**
 * UpdateSubscriptionResponse
 *
 * Response model for updating a subscription
 */
export type UpdateSubscriptionResponse = {
  /**
   * Order Id
   */
  order_id: string;
  /**
   * Organization Id
   */
  organization_id: string;
  order_type: OrderType;
  billing_cycle: BillingCycle;
  order_status: OrderStatus;
  /**
   * Current Period Start
   */
  current_period_start: string;
  /**
   * Current Period End
   */
  current_period_end: string;
  /**
   * Cancel At Period End
   */
  cancel_at_period_end: boolean;
  stripe_subscription_status: StripeSubscriptionStatus;
  new_product?: ProductWithPricesResponse | null;
  old_product?: ProductWithPricesResponse | null;
};

/**
 * UserProfileResponse
 */
export type UserProfileResponse = {
  /**
   * First Name
   */
  first_name: string | null;
  /**
   * Last Name
   */
  last_name: string | null;
  /**
   * Job Title
   */
  job_title: string | null;
  /**
   * User Role
   */
  user_role: string | null;
  /**
   * Marketing Consent
   */
  marketing_consent: boolean | null;
};

/**
 * UserResponse
 */
export type UserResponse = {
  /**
   * Name
   */
  name: string;
  /**
   * Email
   */
  email: string;
};

/**
 * ValidationErrorItem
 */
export type ValidationErrorItem = {
  /**
   * Type
   *
   * The type of error that occurred.
   */
  type: string;
  /**
   * Loc
   *
   * The location of the error in the request.
   */
  loc: Array<unknown>;
  /**
   * Msg
   *
   * A description of the error that occurred.
   */
  msg: string;
  /**
   * Input
   *
   * The input that caused the error.
   */
  input?: unknown;
  /**
   * Ctx
   *
   * Additional context about the error.
   */
  ctx?: {
    [key: string]: unknown;
  };
};

/**
 * ValidationErrorResponse
 */
export type ValidationErrorResponse = {
  /**
   * Detail
   *
   * A description of the error that occurred.
   */
  detail: string;
  /**
   * Status
   *
   * The HTTP status code generated by the server for this issue
   */
  status: number;
  /**
   * Request Id
   *
   * A unique ID associated with the HTTP request.
   */
  request_id: string;
  /**
   * Errors
   *
   * Detailed field-specific errors
   */
  errors?: Array<ValidationErrorItem>;
};

/**
 * WebhookResponse
 */
export type WebhookResponse = {
  /**
   * Url
   */
  url: string;
  /**
   * Status Code
   */
  status_code: number;
};

/**
 * WorkflowInfo
 */
export type WorkflowInfo = {
  /**
   * Id
   *
   * Workflow ID
   */
  id: string;
  /**
   * Api Version
   *
   * API version
   */
  api_version?: string;
  /**
   * Filename
   *
   * The original name of the file passed into the workflow
   */
  filename?: string | null;
  /**
   * Generated At
   *
   * UTC timestamp when the result was generated
   */
  generated_at?: string | null;
  status?: WorkflowStatus;
  /**
   * Type
   *
   * Workflow type: checks, suggestions, or rewrites
   */
  type: string;
  /**
   * The status code received and URL used when sending the webhook if a webhook URL was included when starting the process.
   */
  webhook_response?: WebhookResponse | null;
};

/**
 * WorkflowResponse
 */
export type WorkflowResponse = {
  status: WorkflowStatus;
  /**
   * Workflow Id
   */
  workflow_id: string;
};

/**
 * WorkflowStatus
 */
export enum WorkflowStatus {
  RUNNING = "running",
  COMPLETED = "completed",
  FAILED = "failed",
  NOT_FOUND = "not_found",
}

/**
 * StyleGuide
 */
export type HeliosOneActivitiesEngineSharedModelsStyleGuide = {
  /**
   * The type of style guide to use
   */
  style_guide_type?: StyleGuides | null;
  /**
   * Style Guide Id
   *
   * The ID of the style guide to use
   */
  style_guide_id?: string | null;
};

/**
 * PaginatedInvitationsResponse
 */
export type HeliosOneApiModulesAdminMainPaginatedInvitationsResponse = {
  /**
   * Page
   */
  page: number;
  /**
   * Page Size
   */
  page_size: number;
  /**
   * Invitations
   */
  invitations: Array<InvitedUser>;
};

/**
 * PaginatedMembersResponse
 */
export type HeliosOneApiModulesAdminMainPaginatedMembersResponse = {
  /**
   * Total
   */
  total: number | null;
  /**
   * Page
   */
  page: number;
  /**
   * Page Size
   */
  page_size: number;
  /**
   * Members
   */
  members: Array<OrganizationMember>;
};

/**
 * StyleGuide
 */
export type HeliosOneDatabaseModelsStyleGuideStyleGuide = {
  /**
   * Created By
   *
   * The ID of the user who created the style guide. For now, this is the user's email but will likely be a UUID in the future.
   */
  created_by: string;
  /**
   * Organization Id
   *
   * The ID of the organization that owns the style guide. NULL for system-provided guides.
   */
  organization_id?: string | null;
  /**
   * Created At
   *
   * The date and time the style guide was created.
   */
  created_at?: string | null;
  /**
   * Name
   *
   * A user-friendly name for the style guide.
   */
  name?: string;
  /**
   * Updated By
   *
   * The ID of the user who last updated the style guide. For now, this is the user's email but will likely be a UUID in the future.
   */
  updated_by?: string | null;
  /**
   * Updated At
   *
   * The date and time the style guide was last updated. If null, the style guide has never been updated.
   */
  updated_at?: string | null;
  /**
   * Deleted By
   *
   * The ID of the user who deleted the style guide. For now, this is the user's email but will likely be a UUID in the future.
   */
  deleted_by?: string | null;
  /**
   * Deleted At
   *
   * The date and time the style guide was deleted. If null, the style guide is not deleted.
   */
  deleted_at?: string | null;
  /**
   * The status of the submitted style guide.
   */
  status?: StyleGuideStatus;
  /**
   * The base style guide type (AP, Chicago, Microsoft) that this style guide extends
   */
  base_style_guide_type?: BaseStyleGuideType | null;
  /**
   * Id
   */
  id?: string;
  /**
   * Consistency Prompt
   *
   * Consistency prompt for capitalization, punctuation, numbers, and technical conventions
   */
  consistency_prompt?: string | null;
  /**
   * Tone Prompt
   *
   * Tone prompt for voice and inclusive language
   */
  tone_prompt?: string | null;
  /**
   * Clarity Sentence Structure Prompt
   *
   * Clarity sentence structure prompt for grammar and sentence construction
   */
  clarity_sentence_structure_prompt?: string | null;
  /**
   * Clarity Simple Vocabulary Prompt
   *
   * Clarity simple vocabulary prompt for word choice and vocabulary simplification
   */
  clarity_simple_vocabulary_prompt?: string | null;
  /**
   * Summary
   *
   * User-friendly summary of the style guide's contents and characteristics
   */
  summary?: string | null;
};

/**
 * AccountResponse
 */
export type AccountResponseWritable = {
  organization: OrganizationResponseFullWritable;
  user_profile: UserProfileResponse;
};

/**
 * Issue
 */
export type IssueWritable = {
  /**
   * Original
   *
   * The original text
   */
  original: string;
  /**
   * Position details of the issue
   */
  position: Position;
  /**
   * Subcategory
   *
   * The sub-category of the change
   */
  subcategory:
    | GrammarCategory
    | ClarityCategory
    | ToneCategory
    | ConsistencyCategory
    | TermReplaceCategory;
};

/**
 * OrganizationResponse
 */
export type OrganizationResponseWritable = {
  /**
   * Id
   */
  id: string;
  /**
   * Name
   */
  name: string;
  /**
   * Token Limit
   */
  token_limit: number;
  /**
   * Tokens Used
   */
  tokens_used: number;
  /**
   * Tier
   */
  tier: string;
  /**
   * Style Guide Limit
   */
  style_guide_limit: number;
  /**
   * Term Limit
   */
  term_limit: number;
  /**
   * Display Name
   */
  display_name?: string | null;
  /**
   * Created Date
   */
  created_date: string;
  /**
   * Expiration
   */
  expiration: string | null;
  /**
   * Domain
   */
  domain: string;
  created_by: CreatorResponse | null;
  /**
   * Is Internal
   */
  is_internal: boolean;
  /**
   * Is Acrolinx Classic
   */
  is_acrolinx_classic: boolean;
};

/**
 * OrganizationResponseAdmin
 */
export type OrganizationResponseAdminWritable = {
  /**
   * Id
   */
  id: string;
  /**
   * Name
   */
  name: string;
  /**
   * Token Limit
   */
  token_limit: number;
  /**
   * Tokens Used
   */
  tokens_used: number;
  /**
   * Tier
   */
  tier: string;
  /**
   * Style Guide Limit
   */
  style_guide_limit: number;
  /**
   * Term Limit
   */
  term_limit: number;
  /**
   * Display Name
   */
  display_name?: string | null;
  /**
   * Created Date
   */
  created_date: string;
  /**
   * Expiration
   */
  expiration: string | null;
  /**
   * Domain
   */
  domain: string;
  created_by: CreatorResponse | null;
  /**
   * Style Guides
   */
  style_guides?: number;
  /**
   * Term Sets
   */
  term_sets?: number;
  /**
   * Country
   */
  country: string | null;
  /**
   * Is Internal
   */
  is_internal: boolean;
  /**
   * Is Acrolinx Classic
   */
  is_acrolinx_classic: boolean;
};

/**
 * OrganizationResponseFull
 */
export type OrganizationResponseFullWritable = {
  /**
   * Id
   */
  id: string;
  /**
   * Name
   */
  name: string;
  /**
   * Token Limit
   */
  token_limit: number;
  /**
   * Tokens Used
   */
  tokens_used: number;
  /**
   * Tier
   */
  tier: string;
  /**
   * Style Guide Limit
   */
  style_guide_limit: number;
  /**
   * Term Limit
   */
  term_limit: number;
  /**
   * Display Name
   */
  display_name?: string | null;
  /**
   * Created Date
   */
  created_date: string;
  /**
   * Expiration
   */
  expiration: string | null;
  /**
   * Domain
   */
  domain: string;
  created_by: CreatorResponse | null;
  /**
   * Style Guides
   */
  style_guides?: number;
  /**
   * Term Sets
   */
  term_sets?: number;
  /**
   * Country
   */
  country: string | null;
  /**
   * Is Internal
   */
  is_internal: boolean;
  /**
   * Is Acrolinx Classic
   */
  is_acrolinx_classic: boolean;
};

/**
 * OriginalContent
 */
export type OriginalContentWritable = {
  /**
   * Issues
   */
  issues?: Array<IssueWritable>;
  scores?: ScoreOutput | null;
};

/**
 * Page[APIKeyRead]
 */
export type PageApiKeyReadWritable = {
  /**
   * Items
   */
  items: Array<ApiKeyRead>;
  /**
   * Total Items
   */
  total_items: number;
  /**
   * Page
   */
  page: number;
  /**
   * Page Size
   */
  page_size: number;
};

/**
 * Page[StyleGuide]
 */
export type PageStyleGuideWritable = {
  /**
   * Items
   */
  items: Array<HeliosOneDatabaseModelsStyleGuideStyleGuide>;
  /**
   * Total Items
   */
  total_items: number;
  /**
   * Page
   */
  page: number;
  /**
   * Page Size
   */
  page_size: number;
};

/**
 * Page[TermSetWithTerms]
 */
export type PageTermSetWithTermsWritable = {
  /**
   * Items
   */
  items: Array<TermSetWithTerms>;
  /**
   * Total Items
   */
  total_items: number;
  /**
   * Page
   */
  page: number;
  /**
   * Page Size
   */
  page_size: number;
};

/**
 * PaginatedOrganizationResponse
 */
export type PaginatedOrganizationResponseWritable = {
  /**
   * Total
   */
  total: number;
  /**
   * Page
   */
  page: number;
  /**
   * Page Size
   */
  page_size: number;
  /**
   * Organizations
   */
  organizations: Array<OrganizationResponseWritable>;
};

/**
 * RewriteResponse
 */
export type RewriteResponseWritable = {
  config?: ConfigOptions | null;
  original?: SuggestionOriginalContentWritable | null;
  rewrite?: RewriteContent | null;
  workflow: WorkflowInfo;
};

/**
 * StyleCheckResponse
 */
export type StyleCheckResponseWritable = {
  config?: ConfigOptions | null;
  original?: OriginalContentWritable | null;
  workflow: WorkflowInfo;
};

/**
 * Suggestion
 */
export type SuggestionWritable = {
  /**
   * Original
   *
   * The original text
   */
  original: string;
  /**
   * Position details of the issue
   */
  position: Position;
  /**
   * Subcategory
   *
   * The sub-category of the change
   */
  subcategory:
    | GrammarCategory
    | ClarityCategory
    | ToneCategory
    | ConsistencyCategory
    | TermReplaceCategory;
  /**
   * Suggestion
   *
   * The suggested replacement text
   */
  suggestion: string;
};

/**
 * SuggestionOriginalContent
 */
export type SuggestionOriginalContentWritable = {
  /**
   * Issues
   */
  issues?: Array<SuggestionWritable>;
  scores?: ScoreOutput | null;
};

/**
 * SuggestionResponse
 */
export type SuggestionResponseWritable = {
  config?: ConfigOptions | null;
  original?: SuggestionOriginalContentWritable | null;
  workflow: WorkflowInfo;
};

export type StyleGuidesListStyleGuidesData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/v1/style-guides";
};

export type StyleGuidesListStyleGuidesErrors = {
  /**
   * Authentication failed or no valid API key provided.
   */
  401: ErrorResponse;
  /**
   * Forbidden
   */
  403: ErrorResponse;
  /**
   * Validation error.
   */
  422: ErrorResponse;
  /**
   * Internal Server Error
   */
  500: ErrorResponse;
};

export type StyleGuidesListStyleGuidesError =
  StyleGuidesListStyleGuidesErrors[keyof StyleGuidesListStyleGuidesErrors];

export type StyleGuidesListStyleGuidesResponses = {
  /**
   * Response 200 Style Guides-List Style Guides
   *
   * Successfully retrieved style guides.
   */
  200: Array<StyleGuideResponse>;
};

export type StyleGuidesListStyleGuidesResponse =
  StyleGuidesListStyleGuidesResponses[keyof StyleGuidesListStyleGuidesResponses];

export type StyleGuidesCreateStyleGuideData = {
  body: StyleGuideRequestBody;
  path?: never;
  query?: never;
  url: "/v1/style-guides";
};

export type StyleGuidesCreateStyleGuideErrors = {
  /**
   * Authentication failed or no valid API key provided.
   */
  401: ErrorResponse;
  /**
   * Forbidden
   */
  403: ErrorResponse;
  /**
   * A style guide with this name already exists
   */
  409: ErrorResponse;
  /**
   * The uploaded file exceeds the maximum allowed size.
   */
  413: ErrorResponse;
  /**
   * Unprocessable Entity
   */
  422: ValidationErrorResponse;
  /**
   * Internal Server Error
   */
  500: ErrorResponse;
};

export type StyleGuidesCreateStyleGuideError =
  StyleGuidesCreateStyleGuideErrors[keyof StyleGuidesCreateStyleGuideErrors];

export type StyleGuidesCreateStyleGuideResponses = {
  /**
   * Style guide creation started successfully.
   */
  202: StyleGuideResponse;
};

export type StyleGuidesCreateStyleGuideResponse =
  StyleGuidesCreateStyleGuideResponses[keyof StyleGuidesCreateStyleGuideResponses];

export type StyleGuidesDeleteStyleGuideData = {
  body?: never;
  path: {
    /**
     * Style Guide Id
     *
     * The ID of the style guide.
     */
    style_guide_id: string;
  };
  query?: never;
  url: "/v1/style-guides/{style_guide_id}";
};

export type StyleGuidesDeleteStyleGuideErrors = {
  /**
   * Authentication failed or no valid API key provided.
   */
  401: ErrorResponse;
  /**
   * Cannot delete predefined style guides.
   */
  403: ErrorResponse;
  /**
   * Style guide not found.
   */
  404: ErrorResponse;
  /**
   * Validation error.
   */
  422: ErrorResponse;
  /**
   * Internal Server Error
   */
  500: ErrorResponse;
};

export type StyleGuidesDeleteStyleGuideError =
  StyleGuidesDeleteStyleGuideErrors[keyof StyleGuidesDeleteStyleGuideErrors];

export type StyleGuidesDeleteStyleGuideResponses = {
  /**
   * Style guide successfully deleted.
   */
  204: void;
};

export type StyleGuidesDeleteStyleGuideResponse =
  StyleGuidesDeleteStyleGuideResponses[keyof StyleGuidesDeleteStyleGuideResponses];

export type StyleGuidesGetStyleGuideData = {
  body?: never;
  path: {
    /**
     * Style Guide Id
     *
     * The ID of the style guide.
     */
    style_guide_id: string;
  };
  query?: never;
  url: "/v1/style-guides/{style_guide_id}";
};

export type StyleGuidesGetStyleGuideErrors = {
  /**
   * Authentication failed or no valid API key provided.
   */
  401: ErrorResponse;
  /**
   * Forbidden
   */
  403: ErrorResponse;
  /**
   * Style guide not found or invalid UUID format.
   */
  404: ErrorResponse;
  /**
   * Validation error.
   */
  422: ErrorResponse;
  /**
   * Internal Server Error
   */
  500: ErrorResponse;
};

export type StyleGuidesGetStyleGuideError =
  StyleGuidesGetStyleGuideErrors[keyof StyleGuidesGetStyleGuideErrors];

export type StyleGuidesGetStyleGuideResponses = {
  /**
   * Successfully retrieved the style guide.
   */
  200: StyleGuideResponse;
};

export type StyleGuidesGetStyleGuideResponse =
  StyleGuidesGetStyleGuideResponses[keyof StyleGuidesGetStyleGuideResponses];

export type StyleGuidesUpdateStyleGuideData = {
  body?: BodyStyleGuidesUpdateStyleGuide;
  path: {
    /**
     * Style Guide Id
     *
     * The ID of the style guide.
     */
    style_guide_id: string;
  };
  query?: never;
  url: "/v1/style-guides/{style_guide_id}";
};

export type StyleGuidesUpdateStyleGuideErrors = {
  /**
   * Authentication failed or no valid API key provided.
   */
  401: ErrorResponse;
  /**
   * Cannot update predefined style guides.
   */
  403: ErrorResponse;
  /**
   * Style guide not found.
   */
  404: ErrorResponse;
  /**
   * A style guide with this name already exists
   */
  409: ErrorResponse;
  /**
   * Validation error.
   */
  422: ErrorResponse;
  /**
   * Internal Server Error
   */
  500: ErrorResponse;
};

export type StyleGuidesUpdateStyleGuideError =
  StyleGuidesUpdateStyleGuideErrors[keyof StyleGuidesUpdateStyleGuideErrors];

export type StyleGuidesUpdateStyleGuideResponses = {
  /**
   * The style guide was updated successfully.
   */
  200: StyleGuideResponse;
};

export type StyleGuidesUpdateStyleGuideResponse =
  StyleGuidesUpdateStyleGuideResponses[keyof StyleGuidesUpdateStyleGuideResponses];

export type StyleChecksCreateStyleCheckData = {
  body: StyleCheckRequestBody;
  path?: never;
  query?: never;
  url: "/v1/style/checks";
};

export type StyleChecksCreateStyleCheckErrors = {
  /**
   * Authentication failed or no valid API key provided.
   */
  401: ErrorResponse;
  /**
   * Forbidden
   */
  403: ErrorResponse;
  /**
   * The uploaded file exceeds the maximum allowed size.
   */
  413: ErrorResponse;
  /**
   * The request validation failed.
   */
  422: ValidationErrorResponse;
  /**
   * Token limit exceeded.
   */
  429: ErrorResponse;
  /**
   * Internal Server Error
   */
  500: ErrorResponse;
};

export type StyleChecksCreateStyleCheckError =
  StyleChecksCreateStyleCheckErrors[keyof StyleChecksCreateStyleCheckErrors];

export type StyleChecksCreateStyleCheckResponses = {
  /**
   * Request accepted.
   */
  202: WorkflowResponse;
};

export type StyleChecksCreateStyleCheckResponse =
  StyleChecksCreateStyleCheckResponses[keyof StyleChecksCreateStyleCheckResponses];

export type StyleChecksGetStyleCheckData = {
  body?: never;
  path: {
    /**
     * Workflow Id
     */
    workflow_id: string;
  };
  query?: never;
  url: "/v1/style/checks/{workflow_id}";
};

export type StyleChecksGetStyleCheckErrors = {
  /**
   * Authentication failed or no valid API key provided.
   */
  401: ErrorResponse;
  /**
   * Forbidden
   */
  403: ErrorResponse;
  /**
   * The client attempted to poll or retrieve results for an ID that doesn't exist.
   */
  404: ErrorResponse;
  /**
   * The request validation failed.
   */
  422: ValidationErrorResponse;
  /**
   * An internal server error occurred while fetching the workflow result.
   */
  500: ErrorResponse;
};

export type StyleChecksGetStyleCheckError =
  StyleChecksGetStyleCheckErrors[keyof StyleChecksGetStyleCheckErrors];

export type StyleChecksGetStyleCheckResponses = {
  /**
   * Style check results.
   */
  200: StyleCheckResponse;
};

export type StyleChecksGetStyleCheckResponse =
  StyleChecksGetStyleCheckResponses[keyof StyleChecksGetStyleCheckResponses];

export type StyleChecksCreateStyleCheckBatchData = {
  body: BatchStyleCheckRequestBody;
  path?: never;
  query?: never;
  url: "/v1/style/batch-checks";
};

export type StyleChecksCreateStyleCheckBatchErrors = {
  /**
   * Authentication failed or no valid API key provided.
   */
  401: ErrorResponse;
  /**
   * Forbidden
   */
  403: ErrorResponse;
  /**
   * The uploaded file exceeds the maximum allowed size.
   */
  413: ErrorResponse;
  /**
   * The request validation failed.
   */
  422: ValidationErrorResponse;
  /**
   * Token limit exceeded.
   */
  429: ErrorResponse;
  /**
   * Internal Server Error
   */
  500: ErrorResponse;
};

export type StyleChecksCreateStyleCheckBatchError =
  StyleChecksCreateStyleCheckBatchErrors[keyof StyleChecksCreateStyleCheckBatchErrors];

export type StyleChecksCreateStyleCheckBatchResponses = {
  /**
   * Request accepted.
   */
  202: WorkflowResponse;
};

export type StyleChecksCreateStyleCheckBatchResponse =
  StyleChecksCreateStyleCheckBatchResponses[keyof StyleChecksCreateStyleCheckBatchResponses];

export type StyleChecksGetStyleCheckBatchData = {
  body?: never;
  path: {
    /**
     * Workflow Id
     */
    workflow_id: string;
  };
  query?: never;
  url: "/v1/style/batch-checks/{workflow_id}";
};

export type StyleChecksGetStyleCheckBatchErrors = {
  /**
   * Authentication failed or no valid API key provided.
   */
  401: ErrorResponse;
  /**
   * Forbidden
   */
  403: ErrorResponse;
  /**
   * The client attempted to poll or retrieve results for an ID that doesn't exist.
   */
  404: ErrorResponse;
  /**
   * The request validation failed.
   */
  422: ValidationErrorResponse;
  /**
   * An internal server error occurred while fetching the workflow result.
   */
  500: ErrorResponse;
};

export type StyleChecksGetStyleCheckBatchError =
  StyleChecksGetStyleCheckBatchErrors[keyof StyleChecksGetStyleCheckBatchErrors];

export type StyleChecksGetStyleCheckBatchResponses = {
  /**
   * Batch style check results.
   */
  200: BatchStyleResponse;
};

export type StyleChecksGetStyleCheckBatchResponse =
  StyleChecksGetStyleCheckBatchResponses[keyof StyleChecksGetStyleCheckBatchResponses];

export type StyleSuggestionsCreateStyleSuggestionData = {
  body: StyleSuggestionRequestBody;
  path?: never;
  query?: never;
  url: "/v1/style/suggestions";
};

export type StyleSuggestionsCreateStyleSuggestionErrors = {
  /**
   * Authentication failed or no valid API key provided.
   */
  401: ErrorResponse;
  /**
   * Forbidden
   */
  403: ErrorResponse;
  /**
   * The uploaded file exceeds the maximum allowed size.
   */
  413: ErrorResponse;
  /**
   * The request validation failed.
   */
  422: ValidationErrorResponse;
  /**
   * Token limit exceeded.
   */
  429: ErrorResponse;
  /**
   * Internal Server Error
   */
  500: ErrorResponse;
};

export type StyleSuggestionsCreateStyleSuggestionError =
  StyleSuggestionsCreateStyleSuggestionErrors[keyof StyleSuggestionsCreateStyleSuggestionErrors];

export type StyleSuggestionsCreateStyleSuggestionResponses = {
  /**
   * Request accepted.
   */
  202: WorkflowResponse;
};

export type StyleSuggestionsCreateStyleSuggestionResponse =
  StyleSuggestionsCreateStyleSuggestionResponses[keyof StyleSuggestionsCreateStyleSuggestionResponses];

export type StyleSuggestionsGetStyleSuggestionData = {
  body?: never;
  path: {
    /**
     * Workflow Id
     */
    workflow_id: string;
  };
  query?: never;
  url: "/v1/style/suggestions/{workflow_id}";
};

export type StyleSuggestionsGetStyleSuggestionErrors = {
  /**
   * Authentication failed or no valid API key provided.
   */
  401: ErrorResponse;
  /**
   * Forbidden
   */
  403: ErrorResponse;
  /**
   * The client attempted to poll or retrieve results for an ID that doesn't exist.
   */
  404: ErrorResponse;
  /**
   * The request validation failed.
   */
  422: ValidationErrorResponse;
  /**
   * An internal server error occurred while fetching the workflow result.
   */
  500: ErrorResponse;
};

export type StyleSuggestionsGetStyleSuggestionError =
  StyleSuggestionsGetStyleSuggestionErrors[keyof StyleSuggestionsGetStyleSuggestionErrors];

export type StyleSuggestionsGetStyleSuggestionResponses = {
  /**
   * Suggestion results.
   */
  200: SuggestionResponse;
};

export type StyleSuggestionsGetStyleSuggestionResponse =
  StyleSuggestionsGetStyleSuggestionResponses[keyof StyleSuggestionsGetStyleSuggestionResponses];

export type StyleSuggestionsCreateStyleSuggestionBatchData = {
  body: BatchStyleSuggestionRequestBody;
  path?: never;
  query?: never;
  url: "/v1/style/batch-suggestions";
};

export type StyleSuggestionsCreateStyleSuggestionBatchErrors = {
  /**
   * Authentication failed or no valid API key provided.
   */
  401: ErrorResponse;
  /**
   * Forbidden
   */
  403: ErrorResponse;
  /**
   * The uploaded file exceeds the maximum allowed size.
   */
  413: ErrorResponse;
  /**
   * The request validation failed.
   */
  422: ValidationErrorResponse;
  /**
   * Token limit exceeded.
   */
  429: ErrorResponse;
  /**
   * Internal Server Error
   */
  500: ErrorResponse;
};

export type StyleSuggestionsCreateStyleSuggestionBatchError =
  StyleSuggestionsCreateStyleSuggestionBatchErrors[keyof StyleSuggestionsCreateStyleSuggestionBatchErrors];

export type StyleSuggestionsCreateStyleSuggestionBatchResponses = {
  /**
   * Request accepted.
   */
  202: WorkflowResponse;
};

export type StyleSuggestionsCreateStyleSuggestionBatchResponse =
  StyleSuggestionsCreateStyleSuggestionBatchResponses[keyof StyleSuggestionsCreateStyleSuggestionBatchResponses];

export type StyleSuggestionsGetStyleSuggestionBatchData = {
  body?: never;
  path: {
    /**
     * Workflow Id
     */
    workflow_id: string;
  };
  query?: never;
  url: "/v1/style/batch-suggestions/{workflow_id}";
};

export type StyleSuggestionsGetStyleSuggestionBatchErrors = {
  /**
   * Authentication failed or no valid API key provided.
   */
  401: ErrorResponse;
  /**
   * Forbidden
   */
  403: ErrorResponse;
  /**
   * The client attempted to poll or retrieve results for an ID that doesn't exist.
   */
  404: ErrorResponse;
  /**
   * The request validation failed.
   */
  422: ValidationErrorResponse;
  /**
   * An internal server error occurred while fetching the workflow result.
   */
  500: ErrorResponse;
};

export type StyleSuggestionsGetStyleSuggestionBatchError =
  StyleSuggestionsGetStyleSuggestionBatchErrors[keyof StyleSuggestionsGetStyleSuggestionBatchErrors];

export type StyleSuggestionsGetStyleSuggestionBatchResponses = {
  /**
   * Batch style suggestions results.
   */
  200: BatchStyleResponse;
};

export type StyleSuggestionsGetStyleSuggestionBatchResponse =
  StyleSuggestionsGetStyleSuggestionBatchResponses[keyof StyleSuggestionsGetStyleSuggestionBatchResponses];

export type StyleRewritesCreateStyleRewriteData = {
  body: StyleRewriteRequestBody;
  path?: never;
  query?: never;
  url: "/v1/style/rewrites";
};

export type StyleRewritesCreateStyleRewriteErrors = {
  /**
   * Authentication failed or no valid API key provided.
   */
  401: ErrorResponse;
  /**
   * Forbidden
   */
  403: ErrorResponse;
  /**
   * The uploaded file exceeds the maximum allowed size.
   */
  413: ErrorResponse;
  /**
   * The request validation failed.
   */
  422: ValidationErrorResponse;
  /**
   * Token limit exceeded.
   */
  429: ErrorResponse;
  /**
   * Internal Server Error
   */
  500: ErrorResponse;
};

export type StyleRewritesCreateStyleRewriteError =
  StyleRewritesCreateStyleRewriteErrors[keyof StyleRewritesCreateStyleRewriteErrors];

export type StyleRewritesCreateStyleRewriteResponses = {
  /**
   * Request accepted.
   */
  202: WorkflowResponse;
};

export type StyleRewritesCreateStyleRewriteResponse =
  StyleRewritesCreateStyleRewriteResponses[keyof StyleRewritesCreateStyleRewriteResponses];

export type StyleRewritesGetStyleRewriteData = {
  body?: never;
  path: {
    /**
     * Workflow Id
     */
    workflow_id: string;
  };
  query?: never;
  url: "/v1/style/rewrites/{workflow_id}";
};

export type StyleRewritesGetStyleRewriteErrors = {
  /**
   * Authentication failed or no valid API key provided.
   */
  401: ErrorResponse;
  /**
   * Forbidden
   */
  403: ErrorResponse;
  /**
   * The client attempted to poll or retrieve results for an ID that doesn't exist.
   */
  404: ErrorResponse;
  /**
   * The request validation failed.
   */
  422: ValidationErrorResponse;
  /**
   * An internal server error occurred while fetching the workflow result.
   */
  500: ErrorResponse;
};

export type StyleRewritesGetStyleRewriteError =
  StyleRewritesGetStyleRewriteErrors[keyof StyleRewritesGetStyleRewriteErrors];

export type StyleRewritesGetStyleRewriteResponses = {
  /**
   * Response Style Rewrites-Get Style Rewrite
   *
   * Rewrite results.
   */
  200: RewriteResponse;
};

export type StyleRewritesGetStyleRewriteResponse =
  StyleRewritesGetStyleRewriteResponses[keyof StyleRewritesGetStyleRewriteResponses];

export type GetAdminConstantsData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/v1/internal/constants";
};

export type GetAdminConstantsErrors = {
  /**
   * Authentication failed or no valid API key provided.
   */
  401: ErrorResponse;
  /**
   * Forbidden
   */
  403: ErrorResponse;
  /**
   * Unprocessable Entity
   */
  422: ValidationErrorResponse;
  /**
   * Internal Server Error
   */
  500: ErrorResponse;
};

export type GetAdminConstantsError = GetAdminConstantsErrors[keyof GetAdminConstantsErrors];

export type GetAdminConstantsResponses = {
  /**
   * Successful Response
   */
  200: ConstantsResponse;
};

export type GetAdminConstantsResponse =
  GetAdminConstantsResponses[keyof GetAdminConstantsResponses];
